import threading
import time

from .context import TXS_PER_BLOCK, DIFFICULTY_TARGET
from .validator import serialize_block, hash_block, hash_block_bytes, validate_block

def find_nonce(block):
    assert block[5] == b''

    barr = bytearray(serialize_block(block))
    barr.extend(bytearray(4))
    
    block_hash = None
    nonce = 0
    while True:
        barr[-4:] = nonce.to_bytes(4, 'big')
        block_hash = hash_block_bytes(barr)
        if block_hash < DIFFICULTY_TARGET:
            break
        nonce += 1
    
    block[5] = nonce.to_bytes(4, 'big')


def new_raw_block(index, timestamp, prev_hash, tx_list, prod_key):
    return [index, timestamp, prev_hash, tx_list, prod_key, b'']


class BlockManager:

    def __init__(self, tx_manager, signing_key):
        self.tx_manager = tx_manager
        self.signing_key = signing_key
        self.block_list = []
        self.block_pool = set()
        self.next_index = 0

        self.rlock = threading.RLock()

        tx_manager.add_listener(self.handle_tx_mutation)
    
    def handle_tx_mutation(self):
        tx_queue = self.tx_manager.transaction_queue
        queue_size = len(tx_queue)
        print(f'@@ current # of pending tx for block gen: {queue_size}')
        if queue_size < TXS_PER_BLOCK:
            return

        print('** You are ready to generate blocks')
        return

    def generate_block(self):
        tx_queue = self.tx_manager.transaction_queue

        with self.rlock:
            queue_size = len(tx_queue)
            if queue_size < TXS_PER_BLOCK:
                print('** # of pending tx is not enough')
                print(f'@@ current # of pending tx for block gen: {queue_size}')
                return None
            
            prev_hash = self.block_list[self.next_index - 1] if self.next_index > 0 else bytes(32)
            tx_list = []
            i = TXS_PER_BLOCK
            while i > 0:
                tx = tx_queue.popleft()
                tx_list.append(tx)
                i -= 1

            block_raw = new_raw_block(
                self.next_index, int(time.time()),
                prev_hash, tx_list, self.signing_key
            )

            find_nonce(block_raw)
            self.next_index += 1
            self.store_verified_block(block_raw)

        self.handle_tx_mutation()
        return block_raw

    def store_verified_block(self, block):
        with self.rlock:
            old_list = self.block_list[block[0]:]
            for bl in old_list:
                self.block_pool.remove(hash_block(bl))

            self.block_list[block[0]:] = [block]
            self.block_pool.add(hash_block(block))
            for tx in block[3]:
                self.tx_manager.store_sliently(tx)

    def accept_block(self, block):
        if self.signing_key == block[4]:
            # ignore a block generated by self
            return False
        
        if validate_block(block):
            # discard invalid block
            return False

        index = block[0]
        if index > self.next_index:
            # assume this case won't happen
            return False

        if block[2] != hash_block(self.block_list[index - 1]):
            # prev block not equals
            return False

        if index == self.next_index - 1 and block[1] < self.block_list[index]:
            # take earlier block
            self.next_index -= 1
        
        self.store_verified_block(block)

        return True
